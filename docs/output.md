# ![nf-core/rnaseq](images/nf-core-rnaseq_logo.png)

This document describes the output produced by the pipeline. Most of the plots are taken from the MultiQC report, which summarises results at the end of the pipeline.

The directories listed below will be created in the results directory after the pipeline has finished. All paths are relative to the top-level results directory.

## Pipeline overview

The pipeline is built using [Nextflow](https://www.nextflow.io/) and processes data using the following steps:

* [Preprocessing](#preprocessing)
  * [cat](#cat) - Merge re-sequenced FastQ files
  * [FastQC](#fastqc) - Raw read QC
  * [umi_tools extract](#umi_tools-extract) - UMI barcode extraction
  * [TrimGalore](#trimgalore) - Adapter and quality trimming
  * [SortMeRNA](#sortmerna) - Removal of ribosomal RNA
* [Alignment](#alignment)
  * [STAR](#star) - Fast spliced aware alignment to a reference
  * [RSEM STAR](#rsem-star) - Alignment and quantification of expression levels
  * [HISAT2](#hisat2) - Memory efficient splice aware alignment to a reference
* [Alignment post-processing](#alignment-post-processing)
  * [SAMtools](#samtools) - Sort and index alignments
  * [umi_tools dedup](#umi_tools-dedup) - UMI-based deduplication
  * [picard MarkDuplicates](#picard-markduplicates) - Duplicate read marking
* [Quantification](#quantification)
  * [featureCounts](#featurecounts) - Read counting relative to gene and biotype
* [Quality control](#quality-control)
  * [RSeQC](#rseqc) - Various RNA-seq QC metrics
  * [Qualimap](#qualimap) - Various RNA-seq QC metrics
  * [dupRadar](#dupradar) - Assessment of technical / biological read duplication
  * [Preseq](#preseq) - Estimation of library complexity
  * [edgeR](#edger) - MDS plot and sample pairwise distance heatmap and dendrogram
  * [MultiQC](#multiqc) - Present QC for raw reads, alignment, read counting and sample similiarity
* [Pseudo-alignment and quantification](#pseudo-alignment-and-quantification)
  * [Salmon](#salmon) - Wicked fast gene and isoform quantification relative to the transcriptome
* [Other steps](#other-steps)
  * [StringTie](#stringtie) - Transcript assembly and quantification
* [Workflow reporting and genomes](#workflow-reporting-and-genomes)
  * [Reference genome files](#reference-genome-files) - Saving reference genome indices/files
  * [Pipeline information](#pipeline-information) - Report metrics generated during the workflow execution

## Preprocessing

### cat

<details>
<summary>Output files</summary>

* `fastq/`
  * `*.merged.fastq.gz`: If `--save_merged_fastq` is specified, raw concatenated FastQ files will be placed in this directory.

</details>

If multiple libraries/runs have been provided for the same sample in the input samplesheet (e.g. to increase sequencing depth) then these will be merged at the very beginning of the pipeline in order to have consistent sample naming throughout the pipeline. Please refer to the [usage docs](https://nf-co.re/rnaseq/usage#introduction) to see how to specify these samples in the input samplesheet.

### FastQC

<details>
<summary>Output files</summary>

* `fastqc/`
  * `*_fastqc.html`: FastQC report containing quality metrics.
  * `*_fastqc.zip`: Zip archive containing the FastQC report, tab-delimited data file and plot images.

> **NB:** The FastQC plots in this directory are generated relative to the raw, input reads. They may contain adapter sequence and regions of low quality. To see how your reads look after adapter and quality trimming please refer to the FastQC reports in the `trimgalore/fastqc/` directory.

</details>

[FastQC](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/) gives general quality metrics about your sequenced reads. It provides information about the quality score distribution across your reads, per base sequence content (%A/T/G/C), adapter contamination and overrepresented sequences. For further reading and documentation see the [FastQC help pages](http://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/).

![MultiQC - FastQC per base sequence plot](images/mqc_fastqc_plot.png)

### umi_tools extract

<details>
<summary>Output files</summary>

</details>

TODO

### TrimGalore

<details>
<summary>Output files</summary>

* `trimgalore/`
  * `*.fq.gz`: If `--save_trimmed` is specified, FastQ files **after** adapter trimming will be placed in this directory.
  * `*_trimming_report.txt`: Log file generated by Trim Galore!.
* `trimgalore/fastqc/`
  * `*_fastqc.html`: FastQC report containing quality metrics for read 1 (*and read2 if paired-end*) **after** adapter trimming.
  * `*_fastqc.zip`: Zip archive containing the FastQC report, tab-delimited data file and plot images.

</details>

[Trim Galore!](https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/) is a wrapper tool around Cutadapt and FastQC to peform quality and adapter trimming on FastQ files. By default, Trim Galore! will automatically detect and trim the appropriate adapter sequence. See [usage docs](https://nf-co.re/rnaseq/usage#adapter-trimming) for more details about the trimming options.

![MultiQC - Cutadapt trimmed sequence plot](images/mqc_cutadapt_plot.png)

### SortMeRNA

<details>
<summary>Output files</summary>

* `sortmerna/`
  * `*.fastq.gz`: If `--save_non_ribo_reads` is specified, FastQ files containing non-rRNA reads will be placed in this directory.
  * `*.log`: Log file generated by SortMeRNA with information regarding reads that matched the reference database(s).

</details>

When `--remove_ribo_rna` is specified, the pipeline uses [SortMeRNA](https://github.com/biocore/sortmerna) for the removal of ribosomal RNA. By default, [rRNA databases](https://github.com/biocore/sortmerna/tree/master/data/rRNA_databases) defined in the SortMeRNA GitHub repo are used. You can see an example in the pipeline Github repository in `assets/rrna-default-dbs.txt` which is used by default via the `--ribo_database_manifest` parameter. Please note that commercial/non-academic entities require [`licensing for SILVA`](https://www.arb-silva.de/silva-license-information) for these default databases.

## Alignment

### STAR

<details>
<summary>Output files</summary>

* `star/`
  * `*.Aligned.out.bam`: If `--save_align_intermeds` is specified the original BAM file containing read alignments to the reference genome will be placed in this directory.
  * `*.Aligned.toTranscriptome.out.bam`: If `--save_align_intermeds` is specified the original BAM file containing read alignments to the transcriptome will be placed in this directory.
* `star/log/`
  * `*.SJ.out.tab`: File containing filtered splice junctions detected after mapping the reads
  * `*.Log.final.out`: STAR alignment report containing the mapping results summary
  * `*.Log.out` and `*.Log.progress.out`: STAR log files containing detailed information about the run. Typically only useful for debugging purposes.
* `star/unmapped/`
  * `*.fastq.gz`: If `--save_unaligned` is specified, FastQ files containing unmapped reads will be placed in this directory.

</details>

STAR is a read aligner designed for RNA sequencing. STAR stands for Spliced Transcripts Alignment to a Reference, it produces results comparable to TopHat (the aligned previously used by NGI for RNA alignments) but is much faster.

The STAR section of the MultiQC report shows a bar plot with alignment rates: good samples should have most reads as _Uniquely mapped_ and few _Unmapped_ reads.

![STAR](images/star_alignment_plot.png)

### RSEM STAR

<details>
<summary>Output files</summary>

**Output directory: `results/rsem`**

* `rsem_tpm_gene.txt`
  * Main gene-level TPM matrix including all genes
* `rsem_tpm_isoform.txt`
  * Main isoform-level TPM matrix
* `rsem_transcript_counts_gene.txt`
  * Main gene-level count matrix including all genes
* `rsem_transcript_counts_isoform.txt`
  * Main isoform-level count matrix
* `*.stat`
  * RSEM statistics for each sample
* `*.genes.results`
  * RSEM gene-level output for each sample
* `*.isoforms.results`
  * RSEM isoform-level output for each sample

</details>

[RSEM](https://github.com/deweylab/RSEM) is a software package for estimating gene and isoform expression levels from RNA-Seq data.

### HISAT2

<details>
<summary>Output files</summary>

</details>

TODO

## Alignment post-processing

### SAMtools

<details>
<summary>Output files</summary>

* `variants/bam/`
  * `<SAMPLE>.sorted.bam`: Coordinate sorted BAM file containing read alignment information.
  * `<SAMPLE>.sorted.bam.bai`: Index file for coordinate sorted BAM file.
* `variants/bam/samtools_stats/`
  * SAMtools `<SAMPLE>.sorted.bam.flagstat`, `<SAMPLE>.sorted.bam.idxstats` and `<SAMPLE>.sorted.bam.stats` files generated from the alignment files.

> **NB:** BAM files and their associated indices will only be saved in the results directory if the `--save_align_intermeds` parameter is supplied.

</details>

Bowtie 2 BAM files are further processed with [SAMtools](http://samtools.sourceforge.net/) to sort them by coordinate, for indexing, as well as to generate read mapping statistics.

![MultiQC - SAMtools alignment scores plot](images/mqc_samtools_stats_plot.png)

### umi_tools dedup

<details>
<summary>Output files</summary>

**Output directory: `results/umitools/extract`**

For each sample, this directory contains a log file.
If `--save_umi_intermeds` is specified, this directory additionally contains the
FastQ files with the extracted UMI.

**Output directory: `results/umitools/dedup`**

For each sample, this directory contains summary statistics on the UMI duplication:

```console
<SAMPLE>_edit_distance.tsv
<SAMPLE>_per_umi_per_position.tsv
<SAMPLE>_per_umi.tsv
```

The content of these files is explained [in the UMI tools documentation](https://umi-tools.readthedocs.io/en/latest/reference/dedup.html#dedup-specific-options).

If `--save_umi_intermeds` is specified, this directory additionally contains
the deduplicated BAM file and its associated index.

</details>

UMI-tools deduplicates reads based on unique molecular identifiers (UMIs) to
address PCR-bias. UMI-tools performs two independent steps:

 1. From the raw FastQ files, remove the UMIs and add them to the read name (`extract`)
 2. Deduplicate the aligned BAM files, based on the UMIs. (`dedup`)

### picard MarkDuplicates

<details>
<summary>Output files</summary>

* `variants/bam/`
  * `<SAMPLE>.<SUFFIX>.sorted.bam`: Coordinate sorted BAM file after duplicate marking.
  * `<SAMPLE>.<SUFFIX>.sorted.bam.bai`: Index file for coordinate sorted BAM file after duplicate marking.
* `variants/bam/samtools_stats/`
  * SAMtools `<SAMPLE>.<SUFFIX>.flagstat`, `<SAMPLE>.<SUFFIX>.idxstats` and `<SAMPLE>.<SUFFIX>.stats` files generated from the duplicate marked alignment files.
* `variants/bam/picard_metrics/`
  * `<SAMPLE>.<SUFFIX>.MarkDuplicates.metrics.txt`: Metrics file from MarkDuplicates.

> **NB:** The value of `<SUFFIX>` in the output file names above will depend on the preceeding steps that were run in the pipeline. If `--protocol amplicon` is specified then this process will be run on the iVar trimmed alignments and the value of `<SUFFIX>` will be `trim.mkD`. However, if `--protocol metagenomic` is specified then the process will be run on the alignments obtained directly from Bowtie 2 and the value of `<SUFFIX>` will be `mkD`; where `mkD` is an abbreviation for MarkDuplicates.

</details>

Unless you are using [UMIs](https://emea.illumina.com/science/sequencing-method-explorer/kits-and-arrays/umi.html) it is not possible to establish whether the fragments you have sequenced from your sample were derived via true biological duplication (i.e. sequencing independent template fragments) or as a result of PCR biases introduced during the library preparation. By default, the pipeline uses picard MarkDuplicates to *mark* the duplicate reads identified amongst the alignments to allow you to guage the overall level of duplication in your samples. However, you can also choose to remove any reads identified as duplicates via the `--filter_dups` parameter.

<!-- Read duplicate marking is carried out using the Picard MarkDuplicates command. Duplicate reads are generally removed from the aligned reads to mitigate for fragments in the library that may have been sequenced more than once due to PCR biases. There is an option to keep duplicate reads with the --keep_dups parameter but its generally recommended to remove them to avoid the wrong interpretation of the results. A similar option has been provided to keep reads that are multi-mapped - --keep_multi_map. Other steps have been incorporated into the pipeline to filter the resulting alignments - see main README.md for a more comprehensive listing, and the tools used at each step. A selection of alignment-based QC metrics generated by Picard CollectMultipleMetrics and MarkDuplicates will be included in the MultiQC report. -->

![MultiQC - Picard MarkDuplicates metrics plot](images/mqc_picard_duplicates_plot.png)

## Quantification

### featureCounts

<details>
<summary>Output files</summary>

**Output directory: `results/featurecounts`**

* `Sample.bam_biotype_counts.txt`
  * Read counts for the different gene biotypes that featureCounts distinguishes.
* `Sample.featureCounts.txt`
  * Read counts for each gene provided in the reference `gtf` file
* `Sample.featureCounts.txt.summary`
  * Summary file, containing statistics about the counts
* `merged_gene_counts.txt`
  * Read count table for all samples

</details>

<!-- The featureCounts tool is used to count the number of reads relative to the consensus peak-set across all of the samples. This essentially generates a file containing a matrix where the rows represent the consensus intervals, the columns represent all of the samples in the experiment, and the values represent the raw read counts. -->

[featureCounts](http://bioinf.wehi.edu.au/featureCounts/) from the subread package summarises the read distribution over genomic features such as genes, exons, promotors, gene bodies, genomic bins and chromosomal locations.
RNA reads should mostly overlap genes, so be assigned.

![featureCounts](images/featureCounts_assignment_plot.png)

We also use featureCounts to count overlaps with different classes of features. This gives a good idea of where aligned reads are ending up and can show potential problems such as rRNA contamination.
![biotypes](images/featureCounts_biotype_plot.png)

## Quality control

### RSeQC

RSeQC is a package of scripts designed to evaluate the quality of RNA seq data. You can find out more about the package at the [RSeQC website](http://rseqc.sourceforge.net/).

This pipeline runs several, but not all RSeQC scripts. All of these results are summarised within the MultiQC report and described below.

These are all quality metrics files and contains the raw data used for the plots in the MultiQC report. In general, the `.r` files are R scripts for generating the figures, the `.txt` are summary files, the `.xls` are data tables and the `.pdf` files are summary figures.

#### BAM stat

<details>
<summary>Output files</summary>

**Output directory: `results/rseqc`**
**Output: `Sample_bam_stat.txt`**

</details>

This script gives numerous statistics about the aligned BAM files produced by STAR. A typical output looks as follows:

```txt
#Output (all numbers are read count)
#==================================================
Total records:                                 41465027
QC failed:                                     0
Optical/PCR duplicate:                         0
Non Primary Hits                               8720455
Unmapped reads:                                0

mapq < mapq_cut (non-unique):                  3127757
mapq >= mapq_cut (unique):                     29616815
Read-1:                                        14841738
Read-2:                                        14775077
Reads map to '+':                              14805391
Reads map to '-':                              14811424
Non-splice reads:                              25455360
Splice reads:                                  4161455
Reads mapped in proper pairs:                  21856264
Proper-paired reads map to different chrom:    7648
```

MultiQC plots each of these statistics in a dot plot. Each sample in the project is a dot - hover to see the sample highlighted across all fields.

RSeQC documentation: [bam_stat.py](http://rseqc.sourceforge.net/#bam-stat-py)

#### Infer experiment

<details>
<summary>Output files</summary>

**Output: `Sample_infer_experiment.txt`**

</details>

This script predicts the mode of library preparation (sense-stranded or antisense-stranded) according to how aligned reads overlay gene features in the reference genome.
Example output from an unstranded (~50% sense/antisense) library of paired end data:

**From MultiQC report:**
![infer_experiment](images/rseqc_infer_experiment_plot.png)

**From the `infer_experiment.txt` file:**

```txt
This is PairEnd Data
Fraction of reads failed to determine: 0.0409
Fraction of reads explained by "1++,1--,2+-,2-+": 0.4839
Fraction of reads explained by "1+-,1-+,2++,2--": 0.4752
```

RSeQC documentation: [infer_experiment.py](http://rseqc.sourceforge.net/#infer-experiment-py)

#### Junction saturation

<details>
<summary>Output files</summary>

**Output:**

* `Sample_rseqc.junctionSaturation_plot.pdf`
* `Sample_rseqc.junctionSaturation_plot.r`

</details>

This script shows the number of splice sites detected at the data at various levels of subsampling. A sample that reaches a plateau before getting to 100% data indicates that all junctions in the library have been detected, and that further sequencing will not yield more observations. A good sample should approach such a plateau of _Known junctions_, very deep sequencing is typically requires to saturate all _Novel Junctions_ in a sample.

None of the lines in this example have plateaued and thus these samples could reveal more alternative splicing information if they were sequenced deeper.

![Junction saturation](images/rseqc_junction_saturation_plot.png)

RSeQC documentation: [junction_saturation.py](http://rseqc.sourceforge.net/#junction-saturation-py)

#### RPKM saturation

<details>
<summary>Output files</summary>

**Output:**

* `Sample_RPKM_saturation.eRPKM.xls`
* `Sample_RPKM_saturation.rawCount.xls`
* `Sample_RPKM_saturation.saturation.pdf`
* `Sample_RPKM_saturation.saturation.r`

</details>

This tool resamples a subset of the total RNA reads and calculates the RPKM value for each subset. We use the default subsets of every 5% of the total reads.
A percent relative error is then calculated based on the subsamples; this is the y-axis in the graph. A typical PDF figure looks as follows:

![RPKM saturation](images/saturation.png)

A complex library will have low resampling error in well expressed genes.

This data is not currently reported in the MultiQC report.

RSeQC documentation: [RPKM_saturation.py](http://rseqc.sourceforge.net/#rpkm-saturation-py)

#### Read duplication

<details>
<summary>Output files</summary>

**Output:**

* `Sample_read_duplication.DupRate_plot.pdf`
* `Sample_read_duplication.DupRate_plot.r`
* `Sample_read_duplication.pos.DupRate.xls`
* `Sample_read_duplication.seq.DupRate.xls`

</details>

This plot shows the number of reads (y-axis) with a given number of exact duplicates (x-axis). Most reads in an RNA-seq library should have a low number of exact duplicates. Samples which have many reads with many duplicates (a large area under the curve) may be suffering excessive technical duplication.

![Read duplication](images/rseqc_read_dups_plot.png)

RSeQC documentation: [read_duplication.py](http://rseqc.sourceforge.net/#read-duplication-py)

#### Inner distance

<details>
<summary>Output files</summary>

**Output:**

* `Sample_rseqc.inner_distance.txt`
* `Sample_rseqc.inner_distance_freq.txt`
* `Sample_rseqc.inner_distance_plot.r`

</details>

The inner distance script tries to calculate the inner distance between two paired RNA reads. It is the distance between the end of read 1 to the start of read 2,
and it is sometimes confused with the insert size (see [this blog post](http://thegenomefactory.blogspot.com.au/2013/08/paired-end-read-confusion-library.html) for disambiguation):
![inner distance concept](images/inner_distance_concept.png)

> _Credit: modified from RSeQC documentation._

Note that values can be negative if the reads overlap. A typical set of samples may look like this:
![Inner distance](images/rseqc_inner_distance_plot.png)

This plot will not be generated for single-end data. Very short inner distances are often seen in old or degraded samples (_eg._ FFPE).

RSeQC documentation: [inner_distance.py](http://rseqc.sourceforge.net/#inner-distance-py)

#### Read distribution

<details>
<summary>Output files</summary>

**Output: `Sample_read_distribution.txt`**

</details>

This tool calculates how mapped reads are distributed over genomic features. A good result for a standard RNA seq experiments is generally to have as many exonic reads as possible (`CDS_Exons`). A large amount of intronic reads could be indicative of DNA contamination in your sample or some other problem.

![Read distribution](images/rseqc_read_distribution_plot.png)

RSeQC documentation: [read_distribution.py](http://rseqc.sourceforge.net/#read-distribution-py)

#### Junction annotation

<details>
<summary>Output files</summary>

**Output:**

* `Sample_junction_annotation_log.txt`
* `Sample_rseqc.junction.xls`
* `Sample_rseqc.junction_plot.r`
* `Sample_rseqc.splice_events.pdf`
* `Sample_rseqc.splice_junction.pdf`

</details>

Junction annotation compares detected splice junctions to a reference gene model. An RNA read can be spliced 2 or more times, each time is called a splicing event.

![Junction annotation](images/rseqc_junction_annotation_junctions_plot.png)

RSeQC documentation: [junction_annotation.py](http://rseqc.sourceforge.net/#junction-annotation-py)

### Qualimap

<details>
<summary>Output files</summary>

**Output directory: `results/qualimap`**

* `rnaseq_qc_results.txt`
* `qualimapReport.html`
* `css`
* `raw_data_qualimapReport`
* `images_qualimapReport`

</details>

[Qualimap](http://qualimap.bioinfo.cipf.es/) is a standalone package written in java. It calculates read alignment assignment, transcript coverage, read genomic origin, junction analysis and 3'-5' bias.

Qualimap RNAseq documentation: [Qualimap docs](http://qualimap.bioinfo.cipf.es/doc_html/analysis.html#rna-seq-qc).

### dupRadar

<details>
<summary>Output files</summary>

**Output directory: `results/dupradar`**

* `Sample_markDups.bam_duprateExpDens.pdf`
* `Sample_markDups.bam_duprateExpBoxplot.pdf`
* `Sample_markDups.bam_expressionHist.pdf`
* `Sample_markDups.bam_dupMatrix.txt`
* `Sample_markDups.bam_duprateExpDensCurve.txt`
* `Sample_markDups.bam_intercept_slope.txt`

</details>

[dupRadar](https://www.bioconductor.org/packages/release/bioc/html/dupRadar.html) is a Bioconductor library for R. It plots the duplication rate against expression (RPKM) for every gene. A good sample with little technical duplication will only show high numbers of duplicates for highly expressed genes. Samples with technical duplication will have high duplication for all genes, irrespective of transcription level.

![dupRadar](images/dupRadar_plot.png)

> _Credit: [dupRadar documentation](https://www.bioconductor.org/packages/devel/bioc/vignettes/dupRadar/inst/doc/dupRadar.html)_

DupRadar documentation: [dupRadar docs](https://www.bioconductor.org/packages/devel/bioc/vignettes/dupRadar/inst/doc/dupRadar.html)

### Preseq

<details>
<summary>Output files</summary>

**Output directory: `results/preseq`**

* `bwa/mergedLibrary/preseq/`
  * `*.ccurve.txt`: Preseq expected future yield file.

</details>

<!-- The Preseq package is aimed at predicting and estimating the complexity of a genomic sequencing library, equivalent to predicting and estimating the number of redundant reads from a given sequencing depth and how many will be expected from additional sequencing using an initial sequencing experiment. The estimates can then be used to examine the utility of further sequencing, optimize the sequencing depth, or to screen multiple libraries to avoid low complexity samples. The dashed line shows a perfectly complex library where total reads = unique reads. Note that these are predictive numbers only, not absolute. The MultiQC plot can sometimes give extreme sequencing depth on the X axis - click and drag from the left side of the plot to zoom in on more realistic numbers. -->

[Preseq](http://smithlabresearch.org/software/preseq/) estimates the complexity of a library, showing how many additional unique reads are sequenced for increasing the total read count. A shallow curve indicates that the library has reached complexity saturation and further sequencing would likely not add further unique reads. The dashed line shows a perfectly complex library where total reads = unique reads.

Note that these are predictive numbers only, not absolute. The MultiQC plot can sometimes give extreme sequencing depth on the X axis - click and drag from the left side of the plot to zoom in on more realistic numbers.

![preseq](images/preseq_plot.png)

### edgeR

<details>
<summary>Output files</summary>

**Output directory: `results/sample_correlation`**

* `edgeR_MDS_plot.pdf`
  * MDS scatter plot showing sample similarity
* `edgeR_MDS_distance_matrix.csv`
  * Distance matrix containing raw data from MDS analysis
* `edgeR_MDS_Aplot_coordinates_mqc.csv`
  * Scatter plot coordinates from MDS plot, used for MultiQC report
* `log2CPM_sample_distances_dendrogram.pdf`
  * Dendrogram showing the Euclidean distance between your samples
* `log2CPM_sample_correlation_heatmap.pdf`
  * Heatmap showing the Pearsons correlation between your samples
* `log2CPM_sample_correlation_mqc.csv`
  * Raw data from Pearsons correlation heatmap, used for MultiQC report

</details>

[edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html) is a Bioconductor package for R used for RNA-seq data analysis. The script included in the pipeline uses edgeR to normalise read counts and create a heatmap showing Pearson's correlation and a dendrogram showing pairwise Euclidean distances between the samples in the experiment. It also creates a 2D MDS scatter plot showing sample grouping. These help to show sample similarity and can reveal batch effects and sample groupings.

![heatmap](images/mqc_hcplot_hocmzpdjsq.png)

![mds_plot](images/mqc_hcplot_ltqchiyxfz.png)

### MultiQC

<details>
<summary>Output files</summary>

* `multiqc/`  
  * `multiqc_report.html`: a standalone HTML file that can be viewed in your web browser.
  * `multiqc_data/`: directory containing parsed statistics from the different tools used in the pipeline.
  * `multiqc_plots/`: directory containing static images from the report in various formats.

</details>

[MultiQC](http://multiqc.info) is a visualization tool that generates a single HTML report summarizing all samples in your project. Most of the pipeline QC results are visualised in the report and further statistics are available in the report data directory.

Results generated by MultiQC collate pipeline QC from FastQC, fastp, Cutadapt, Bowtie 2, Kraken 2, VarScan 2, iVar, samtools flagstat, samtools idxstats, samtools stats, picard CollectMultipleMetrics and CollectWgsMetrics, BCFTools, SnpEff and QUAST.

The default [`multiqc config file`](https://github.com/nf-core/viralrecon/blob/master/assets/multiqc_config.yaml) has been written in a way in which to structure these QC metrics to make them more interpretable in the final report.

The pipeline has special steps which also allow the software versions to be reported in the MultiQC output for future traceability. For more information about how to use MultiQC reports, see <http://multiqc.info>.

Please click [here](https://raw.githack.com/nf-core/viralrecon/master/docs/html/multiqc_report.html) to see an example MultiQC report generated using the parameters defined in [this configuration file](https://github.com/nf-core/viralrecon/blob/master/conf/test_full.config) to run the pipeline on [samples](https://zenodo.org/record/3735111) which were prepared from the [ncov-2019 ARTIC Network V1 amplicon set](https://artic.network/ncov-2019) and sequenced on the Illumina MiSeq platform in 301bp paired-end format.

<!-- [MultiQC](http://multiqc.info) is a visualization tool that generates a single HTML report summarizing all samples in your project. Most of the pipeline QC results are visualised in the report and further statistics are available in the report data directory.

The pipeline has special steps which also allow the software versions to be reported in the MultiQC output for future traceability.

For more information about how to use MultiQC reports, see [https://multiqc.info](https://multiqc.info).

**Output files:**

* `multiqc/`  
  * `multiqc_report.html`: a standalone HTML file that can be viewed in your web browser.
  * `multiqc_data/`: directory containing parsed statistics from the different tools used in the pipeline.
  * `multiqc_plots/`: directory containing static images from the report in various formats. -->

<!-- MultiQC is a visualisation tool that generates a single HTML report summarising all samples in your project. Most of the pipeline QC results are visualised in the report and further statistics are available within the report data directory.

Results generated by MultiQC collate pipeline QC from FastQC, TrimGalore, samtools flagstat, samtools idxstats, samtools stats, picard CollectMultipleMetrics, picard MarkDuplicates, Preseq, deepTools plotProfile, deepTools plotFingerprint, phantompeakqualtools and featureCounts. The default multiqc config file also contains the provision for loading custom-content to report peak counts, FRiP scores, peak-to-gene annnotation proportions, spp NSC coefficient, spp RSC coefficient, PCA plots and sample-similarity heatmaps.

The pipeline has special steps which also allow the software versions to be reported in the MultiQC output for future traceability. For more information about how to use MultiQC reports, see http://multiqc.info. -->

## Pseudo-alignment and quantification

### Salmon

<details>
<summary>Output files</summary>

**Output directory: `results/salmon`**

* `Sample/quant.sf`
  * Read counts for the different transcripts.
* `Sample/quant.genes.sf`
  * Read the counts for each gene provided in the reference `gtf` file
* `Sample/logs`
  * Summary file with information about the process
* `unaligned/`
  * Contains a list of unmapped reads that can be used to generate a FastQ of unmapped reads for downstream analysis.

</details>

[Salmon](https://salmon.readthedocs.io/en/latest/salmon.html) from [Ocean Genomics](https://oceangenomics.com/) quasi-maps and quantifies expression relative to the transcriptome.

#### tximport

<details>
<summary>Output files</summary>

**Output directory: `results/salmon`**

* `salmon_merged_transcript_tpm.csv`
  * TPM counts for the different transcripts.
* `salmon_merged_gene_tpm.csv`
  * TPM counts for the different genes.
* `salmon_merged_transcript_counts.csv`
  * estimated counts for the different transcripts.
* `salmon_merged_gene_counts.csv`
  * estimated counts for the different genes.
* `tx2gene.csv`
  * CSV file with transcript and genes (`params.fc_group_features`) and extra name (`params.fc_extra_attributes`) in each column.
* `salmon_merged_transcript_counts.rds`
  * RDS object to be loaded in R that contains a [SummarizedExperiment](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) with the TPM (`abundance`), estimated counts (`counts`) and transcript length (`length`) in the assays slot for transcripts.
* `salmon_merged_gene_counts.rds`
  * RDS object to be loaded in R that contains a [SummarizedExperiment](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) with the TPM (`abundance`), estimated counts (`counts`) and transcript length (`length`) in the assays slot for genes.

</details>

[tximport](https://bioconductor.org/packages/release/bioc/html/tximport.html) imports transcript-level abundance, estimated counts and transcript lengths, and summarizes into matrices for use with downstream gene-level analysis packages. Average transcript length, weighted by sample-specific transcript abundance estimates, is provided as a matrix which can be used as an offset for different expression of gene-level counts.

#### Index files

<details>
<summary>Output files</summary>

**Output directory: `results/reference/genome/salmon_index`**

* `duplicate_clusters.tsv`
  * Stores which transcripts are duplicates of one another
* `hash.bin`
* `header.json`
  * Information about k-mer size, uniquely identifying hashes for the reference
* `indexing.log`
  * Time log for creating transcriptome index
* `quasi_index.log`
  * Step-by-step log for making transcriptome index
* `refInfo.json`
  * Information about file used for the reference
* `rsd.bin`
* `sa.bin`
* `txpInfo.bin`
* `versionInfo.json`
  * Salmon and indexing version sed to make the index

</details>

#### Quantification output

<details>
<summary>Output files</summary>

**Output directory: `results/salmon`**

* `aux_info/`
  * Auxiliary info e.g. versions and number of mapped reads
* `cmd_info.json`
  * Information about the Salmon quantification command, version, and options
* `lib_format_counts.json`
  * Number of fragments assigned, unassigned and incompatible
* `libParams/`
  * Contains the file `flenDist.txt` for the fragment length distribution
* `logs/`
  * Contains the file `salmon_quant.log` giving a record of Salmon's quantification
* `quant.sf`
  * _Transcript_-level quantification of the sample, including gene length, effective length, TPM, and number of reads
* `quant.genes.sf`
  * _Gene_-level quantification of the sample, including gene length, effective length, TPM, and number of reads
* `Sample.transcript.tpm.txt`
  * Subset of `quant.sf`, only containing the transcript id and TPM values
* `Sample.gene.tpm.txt`
  * Subset of `quant.genes.sf`, only containing the gene id and TPM values

</details>

## Other steps

### StringTie

<details>
<summary>Output files</summary>

**Output directory: `results/stringtie`**

* `<sample>_Aligned.sortedByCoord.out.bam.gene_abund.txt`
  * Gene aboundances, FPKM values
* `<sample>_Aligned.sortedByCoord.out.bam_transcripts.gtf`
  * This `.gtf` file contains all of the assembled transcipts from StringTie
* `<sample>_Aligned.sortedByCoord.out.bam.cov_refs.gtf`
  * This `.gtf` file contains the transcripts that are fully covered by reads.

</details>

[StringTie](https://ccb.jhu.edu/software/stringtie/) assembles RNA-Seq alignments into potential transcripts. It assembles and quantitates full-length transcripts representing multiple splice variants for each gene locus.

StringTie outputs FPKM metrics for genes and transcripts as well as the transcript features that it generates.

## Workflow reporting and genomes

### Reference genome files

<details>
<summary>Output files</summary>

* `genome/`  
  * `BlastDB/`: BLAST database for viral genome.
  * `Bowtie2Index/`: Bowtie 2 index for viral genome.
  * `kraken2_<KRAKEN2_DB_NAME>/`: Kraken 2 database for host genome.
  * `SnpEffDB/`: SnpEff database for viral genome.
  * `snpeff.config`: SnpEff config file for viral genome.
  * Unzipped genome fasta file for viral genome
  * Unzipped genome annotation GFF file for viral genome

</details>

A number of genome-specific files are generated by the pipeline because they are required for the downstream processing of the results. If the `--save_reference` parameter is provided then the Bowtie 2 alignment indices, BLAST and Kraken 2 databases downloaded/generated by the pipeline will be saved in the `genome/` directory. It is recommended to use the `--save_reference` parameter if you are using the pipeline to build a Kraken 2 database for the host genome. This can be quite a time-consuming process and it permits their reuse for future runs of the pipeline or for other purposes.

### Pipeline information

<details>
<summary>Output files</summary>

* `pipeline_info/`
  * Reports generated by Nextflow: `execution_report.html`, `execution_timeline.html`, `execution_trace.txt` and `pipeline_dag.dot`/`pipeline_dag.svg`.
  * Reports generated by the pipeline: `pipeline_report.html`, `pipeline_report.txt` and `software_versions.csv`.
  * Reformatted samplesheet files used as input to the pipeline: `samplesheet.valid.csv`.
  * Documentation for interpretation of results in HTML format: `results_description.html`.

</details>

[Nextflow](https://www.nextflow.io/docs/latest/tracing.html) provides excellent functionality for generating various reports relevant to the running and execution of the pipeline. This will allow you to troubleshoot errors with the running of the pipeline, and also provide you with other information such as launch commands, run times and resource usage.

<!-- [Nextflow](https://www.nextflow.io/docs/latest/tracing.html) provides excellent functionality for generating various reports relevant to the running and execution of the pipeline. This will allow you to troubleshoot errors with the running of the pipeline, and also provide you with other information such as launch commands, run times and resource usage.

**Output files:**

* `pipeline_info/`
  * Reports generated by Nextflow: `execution_report.html`, `execution_timeline.html`, `execution_trace.txt` and `pipeline_dag.dot`/`pipeline_dag.svg`.
  * Reports generated by the pipeline: `pipeline_report.html`, `pipeline_report.txt` and `software_versions.csv`.
  * Documentation for interpretation of results in HTML format: `results_description.html`. --> -->
